// https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/

pub struct Solution;

// Initial sol'n (failed)
// impl Solution {
//     pub fn longest_subarray(nums: Vec<i32>, limit: i32) -> i32 {
//         let mut left = 0;
//         let mut right = 0;
//         let mut min_heap = std::collections::BinaryHeap::new();
//         let mut max_heap = std::collections::BinaryHeap::new();
//         let mut dropped = std::collections::HashMap::new();
//         let mut result = 0;
//         loop {
//             if right == nums.len() {
//                 break;
//             }
//             min_heap.push(std::cmp::Reverse(nums[right]));
//             max_heap.push(nums[right]);
//             while max_heap.peek().unwrap() - min_heap.peek().unwrap().0 > limit && left < right {
//                 let left_val = nums[left];
//                 let left_count = dropped.entry(left_val).or_insert(0);
//                 *left_count += 1;
//                 while let Some(&count) = dropped.get(&min_heap.peek().unwrap().0) {
//                     if count == 0 {
//                         break;
//                     }
//                     let min_val = min_heap.pop().unwrap().0;
//                     *dropped.get_mut(&min_val).unwrap() -= 1;
//                 }
//                 while let Some(&count) = dropped.get(&max_heap.peek().unwrap()) {
//                     if count == 0 {
//                         break;
//                     }
//                     let max_val = max_heap.pop().unwrap();
//                     *dropped.get_mut(&max_val).unwrap() -= 1;
//                 }
//                 left += 1;
//             }
//             result = std::cmp::max(result, right - left + 1);
//             right += 1;
//         }
//         result as i32
//     }
// }

// Third sol'n (finally passing; second was almost the same, but N^2 if all elemnts were the same)
// impl Solution {
//     pub fn longest_subarray(nums: Vec<i32>, limit: i32) -> i32 {
//         let mut left = 0;
//         let mut right = 1;
//         let mut result = 1;
//         let mut min = nums[0];
//         let mut max = nums[0];
//         loop {
//             while right < nums.len() && (max - min <= limit) {
//                 result = std::cmp::max(result, right - left);
//                 min = std::cmp::min(min, nums[right]);
//                 max = std::cmp::max(max, nums[right]);
//                 right += 1;
//             }
//             while left < right && max - min > limit {
//                 let oldleft = left;
//                 left += 1;
//                 if (nums[oldleft] == min) ^ (nums[oldleft] == max) {
//                     min = nums[left..right].iter().copied().min().unwrap();
//                     max = nums[left..right].iter().copied().max().unwrap();
//                 }
//             }
//             if right == nums.len() {
//                 if max - min <= limit {
//                     result = std::cmp::max(result, right - left);
//                 }
//                 break;
//             }
//         }
//         result as i32
//     }
// }

// Fourth sol'n (fixing the heaps)
// impl Solution {
//     pub fn longest_subarray(nums: Vec<i32>, limit: i32) -> i32 {
//         /// A max heap set that supports fast insertion, erasure, and
//         /// max-peeking.
//         /// It is illegal to call any method but `insert` on an empty
//         /// `MaxMultiSet`.
//         struct MaxMultiSet<T> {
//             maxheap: std::collections::BinaryHeap<T>,
//             dropped: std::collections::HashMap<T, u32>,
//         }
//         impl<T: Ord> MaxMultiSet<T> {
//             fn new() -> Self {
//                 MaxMultiSet {
//                     maxheap: std::collections::BinaryHeap::new(),
//                     dropped: std::collections::HashMap::new(),
//                 }
//             }
//             fn insert(&mut self, val: T) {
//                 self.maxheap.push(val);
//             }
//             fn remove(&mut self, val: T)
//                 where T: Copy + Eq + std::hash::Hash,
//             {
//                 let count = self.dropped.entry(val).or_insert(0);
//                 *count += 1;
//                 if *self.maxheap.peek().unwrap() == val {
//                     while let Some(count) = self.dropped.get_mut(&*self.maxheap.peek().unwrap()) {
//                         if *count == 0 {
//                             break;
//                         }
//                         *count -= 1;
//                         self.maxheap.pop();
//                     }
//                 }
//             }
//             fn peek(&self) -> &T {
//                 self.maxheap.peek().unwrap()
//             }
//         }
//         fn check_limit(
//             min_multiset: &MaxMultiSet<std::cmp::Reverse<i32>>,
//             max_multiset: &MaxMultiSet<i32>,
//             limit: i32,
//         ) -> bool {
//             max_multiset.peek() - min_multiset.peek().0 <= limit
//         }
//         let mut left = 0;
//         let mut right = 1;
//         let mut result = 1;
//         let mut min_multiset = MaxMultiSet::new();
//         min_multiset.insert(std::cmp::Reverse(nums[0]));
//         let mut max_multiset = MaxMultiSet::new();
//         max_multiset.insert(nums[0]);
//         loop {
//             while right < nums.len() && check_limit(&min_multiset, &max_multiset, limit) {
//                 result = std::cmp::max(result, right - left);
//                 min_multiset.insert(std::cmp::Reverse(nums[right]));
//                 max_multiset.insert(nums[right]);
//                 right += 1;
//             }
//             while left < right && !check_limit(&min_multiset, &max_multiset, limit) {
//                 let left_val = nums[left];
//                 left += 1;
//                 min_multiset.remove(std::cmp::Reverse(left_val));
//                 max_multiset.remove(left_val);
//             }
//             if right == nums.len() {
//                 if check_limit(&min_multiset, &max_multiset, limit) {
//                     result = std::cmp::max(result, right - left);
//                 }
//                 break;
//             }
//         }
//         result as i32
//     }
// }

// Fifth sol'n (using just one multiset)
// impl Solution {
//     pub fn longest_subarray(nums: Vec<i32>, limit: i32) -> i32 {
//         /// A set that supports fast insertion, erasure, max- and min-peeking.
//         /// It is illegal to call any method but `insert` on an empty
//         /// `BinaryMultiSet`.
//         struct BinaryMultiSet<T> {
//             binaryheap: std::collections::BTreeMap<T, u32>
//         }
//         impl<T: Ord> BinaryMultiSet<T> {
//             fn new() -> Self {
//                 Self {
//                     binaryheap: std::collections::BTreeMap::new(),
//                 }
//             }
//             fn insert(&mut self, val: T) {
//                 self.binaryheap.entry(val).and_modify(|count| *count += 1).or_insert(1);
//             }
//             fn remove(&mut self, val: T)
//                 where T: Copy + Eq,
//             {
//                 let count = self.binaryheap.get_mut(&val).unwrap();
//                 *count -= 1;
//                 if *count == 0 {
//                     self.binaryheap.remove(&val);
//                 }
//             }
//             fn peek_max(&self) -> &T {
//                 self.binaryheap.last_key_value().unwrap().0
//             }
//             fn peek_min(&self) -> &T {
//                 self.binaryheap.first_key_value().unwrap().0
//             }
//         }
//         fn check_limit(
//             multiset: &BinaryMultiSet<i32>,
//             limit: i32,
//         ) -> bool {
//             multiset.peek_max() - multiset.peek_min() <= limit
//         }
//         let mut left = 0;
//         let mut right = 1;
//         let mut result = 1;
//         let mut multiset = BinaryMultiSet::new();
//         multiset.insert(nums[0]);
//         loop {
//             while right < nums.len() && check_limit(&multiset, limit) {
//                 result = std::cmp::max(result, right - left);
//                 multiset.insert(nums[right]);
//                 right += 1;
//             }
//             while left < right && !check_limit(&multiset, limit) {
//                 let left_val = nums[left];
//                 left += 1;
//                 multiset.remove(left_val);
//             }
//             if right == nums.len() {
//                 if check_limit(&multiset, limit) {
//                     result = std::cmp::max(result, right - left);
//                 }
//                 break;
//             }
//         }
//         result as i32
//     }
// }

// Deque sol'n (based on cribbing from best sol'n in distribution)
// impl Solution {
//     pub fn longest_subarray(nums: Vec<i32>, limit: i32) -> i32 {
//         assert!(nums.len() >= 1);
//         assert!(nums.len() <= 100_000);
//         let mut min_deque = std::collections::VecDeque::new();
//         let mut max_deque = std::collections::VecDeque::new();
//         let mut left: u32 = 0;
//         let mut right: u32 = 0;
//         let mut result: i32 = 0;
//         while right < nums.len() as u32 {
//             while !min_deque.is_empty()
//                 && nums[right as usize] < nums[*min_deque.back().unwrap() as usize]
//             {
//                 min_deque.pop_back();
//             }
//             while !max_deque.is_empty()
//                 && nums[right as usize] > nums[*max_deque.back().unwrap() as usize]
//             {
//                 max_deque.pop_back();
//             }
//             min_deque.push_back(right);
//             max_deque.push_back(right);
//             while nums[*max_deque.front().unwrap() as usize] - nums[*min_deque.front().unwrap() as usize] > limit {
//                 if *max_deque.front().unwrap() == left {
//                     max_deque.pop_front();
//                 }
//                 if *min_deque.front().unwrap() == left {
//                     min_deque.pop_front();
//                 }
//                 left += 1;
//             }
//             result = std::cmp::max(result, (right - left) as i32 + 1);
//             right += 1;
//         }
//         result
//     }
// }

// Deque sol'n v2 (less indirection maybe?)
// impl Solution {
//     pub fn longest_subarray(nums: Vec<i32>, limit: i32) -> i32 {
//         assert!(nums.len() >= 1);
//         assert!(nums.len() <= 100_000);
//         let mut min_deque = std::collections::VecDeque::new();
//         let mut max_deque = std::collections::VecDeque::new();
//         let mut left: u32 = 0;
//         let mut right: u32 = 0;
//         let mut result: i32 = 0;
//         while right < nums.len() as u32 {
//             let right_val = nums[right as usize];
//             while !min_deque.is_empty()
//                 && right_val < *min_deque.back().unwrap()
//             {
//                 min_deque.pop_back();
//             }
//             while !max_deque.is_empty()
//                 && right_val > *max_deque.back().unwrap()
//             {
//                 max_deque.pop_back();
//             }
//             min_deque.push_back(right_val);
//             max_deque.push_back(right_val);
//             while *max_deque.front().unwrap() - *min_deque.front().unwrap() > limit {
//                 let left_val = nums[left as usize];
//                 if *max_deque.front().unwrap() == left_val {
//                     max_deque.pop_front();
//                 }
//                 if *min_deque.front().unwrap() == left_val {
//                     min_deque.pop_front();
//                 }
//                 left += 1;
//             }
//             result = std::cmp::max(result, (right - left) as i32 + 1);
//             right += 1;
//         }
//         result
//     }
// }

// New from sol'n best
impl Solution {
    pub fn longest_subarray(nums: Vec<i32>, limit: i32) -> i32 {
        assert!(nums.len() >= 1);
        assert!(nums.len() <= 100_000);
        let mut min_deque = std::collections::VecDeque::new();
        let mut max_deque = std::collections::VecDeque::new();
        let mut left: u32 = 0;
        let mut right: u32 = 0;
        let mut result: i32 = 0;
        while right < nums.len() as u32 {
            let right_val = nums[right as usize];
            loop {
                let Some(&back_val) = min_deque.back() else {
                    break;
                };
                if back_val <= right_val {
                    break;
                }
                _ = min_deque.pop_back()
            }
            min_deque.push_back(right_val);
            loop {
                let Some(&back_val) = max_deque.back() else {
                    break;
                };
                if back_val >= right_val {
                    break;
                }
                _ = max_deque.pop_back()
            }
            max_deque.push_back(right_val);
            loop {
                let min = *min_deque.front().unwrap();
                let max = *max_deque.front().unwrap();
                if max - min <= limit {
                    break;
                }
                let left_val = nums[left as usize];
                left += 1;
                if left_val == min {
                    _ = min_deque.pop_front();
                }
                if left_val == max {
                    _ = max_deque.pop_front();
                }
            }
            result = std::cmp::max(result, (right - left) as i32 + 1);
            right += 1;
        }
        result
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn test(nums: &[i32], limit: u32, expected: u32) {
        assert!(nums.len() >= 1);
        assert!(nums.len() <= 100_000);
        for num in nums {
            assert!(*num >= 1);
            assert!(*num <= 1_000_000_000);
        }
        assert!(limit < 1_000_000_000);
        assert!(expected <= nums.len() as u32);
        assert_eq!(
            Solution::longest_subarray(nums.to_vec(), limit as i32),
            expected as i32
        )
    }

    #[test]
    fn ex1() {
        test(&[8, 2, 4, 7], 4, 2)
    }

    #[test]
    fn ex2() {
        test(&[10, 1, 2, 4, 7, 2], 5, 4)
    }

    #[test]
    fn ex3() {
        test(&[4, 2, 2, 2, 4, 4, 2, 2], 0, 3)
    }

    #[test]
    fn discussion_case1() {
        test(&[1, 5, 6, 7, 8, 10, 6, 5, 6], 4, 5)
    }

    #[test]
    fn discussion_case2() {
        // test 53
        test(
            &[
                8952, 1216, 3953, 6254, 2285, 4681, 3317, 6508, 5847, 2922, 3689, 4880, 2357, 5698,
                8063, 8772, 4781, 1452, 8427, 4898, 3422, 7594, 359, 4757, 9710, 1689, 6106, 7268,
                4177, 955, 854, 5171, 2620, 2169, 1693, 1844, 7132, 9610, 4029, 3406, 8262, 8319,
                6502, 1992, 3477, 6289, 8478, 2195, 9476, 4172, 60, 1981, 3303, 9220, 6194, 7898,
                8930, 3780, 4386, 618, 2749, 9083, 8239, 3820, 6725, 4485, 6901, 6530, 4457, 8094,
                1602, 2124, 3059, 9168, 261, 7438, 735, 8003, 3512, 6455, 8826, 5510, 3990, 1541,
                1264, 699, 6925, 7239, 3094, 2839, 9754, 8225, 3113, 8352, 6305, 8550, 5908, 3229,
                3813, 5894, 9602, 1057, 5588, 849, 7512, 725, 2897, 2420, 4679, 7687, 706, 9558,
                8210, 1063, 9265, 6493, 1508, 6553, 8385, 9379, 4937, 6462, 4390, 5771, 7711, 805,
                9048, 7818, 286, 6994, 4991, 9645, 5199, 2448, 9767, 9656, 9106, 4552, 1080, 9948,
                5915, 6802, 6407, 8517, 388, 9432, 9532, 1860, 606, 9402, 8677, 236, 1654, 5441,
                5517, 6035, 9026, 565, 6065, 9548, 1216, 7946, 1373, 8841, 7311, 5481, 8194, 8915,
                56, 2634, 5326, 5913, 3506, 2395, 9507, 2429, 9660, 1768, 6619, 5198, 8334, 6896,
                5899, 5594, 4257, 9976, 6038, 617, 1040, 4042, 4351, 6506, 9018, 4651, 9401, 1368,
                1228, 2792, 4380, 6780, 1365, 2069, 4628, 9025, 4306, 3848, 3451, 1620, 4541, 7872,
                772, 8392, 4937, 3341, 8908, 1231, 9023, 5169, 5566, 4851, 8457, 2184, 578, 7246,
                5963, 611, 471, 5169, 6841, 2684, 9126, 666, 9640, 8616, 6957, 3021, 3235, 3815,
                1881, 9625, 2131, 9613, 8295, 2007, 4368, 7510, 3217, 906, 5920, 7474, 5488, 5812,
                3601, 154, 229, 8008, 529, 2694, 4151, 9044, 654, 151, 3770, 1387, 8591, 2840, 576,
                8654, 3281, 3432, 7258, 4732, 3982, 8037, 8289, 6085, 5324, 6423, 1204, 3199, 9738,
                2974, 3073, 4866, 9524, 6984, 7767, 5956, 380, 7985, 339, 1717, 9470, 7086, 9539,
                5630, 5553, 1214, 6885, 3200, 8426, 8100, 9961, 9235, 9018, 8210, 7826, 9830, 9433,
                7375, 9892, 7720, 2710, 4396, 8593, 4941, 9232, 6496, 9952, 8843, 4246, 4185, 5084,
                241, 9906, 752, 7497, 7497, 5826, 3804, 8323, 7278, 3427, 7799, 5499, 2373, 6290,
                7166, 889, 1823, 5838, 135, 4192, 8866, 886, 5021, 6206, 246, 5317, 5541, 5060,
                9654, 815, 3418, 1340, 5385, 1965, 1086, 2104, 4822, 6712, 9953, 5584, 3811, 446,
                2999, 8261, 9406, 5994, 4957, 4813, 6194, 6889, 8625, 7561, 1216, 3261, 6680, 3795,
                9960, 692, 3945, 3680, 3990, 6467, 6216, 3444, 2491, 4903, 5900, 24, 5035, 7279,
                8158, 2800, 2399, 511, 6075, 7160, 9076, 5602, 8409, 8024, 5204, 9893, 1828, 9562,
                4789, 8980, 4524, 7038, 186, 5091, 1417, 8060, 1884, 8211, 3614, 9923, 4337, 7157,
                6107, 3778, 889, 1680, 9780, 8442, 8425, 8378, 2672, 2126, 4786, 792, 1120, 3576,
                52, 1013, 6930, 345, 1085, 902, 147, 572, 8814, 5557, 5452, 308, 145, 9160, 3463,
                7684, 3279, 4363, 4840, 9531, 9023, 8545, 4119, 3826, 2993, 3453, 6414, 980, 3910,
                9099, 7416, 580, 5430, 5353, 6665, 1962, 263, 9217, 3032, 8284, 1535, 3029, 3578,
                3685, 2893, 4984, 1603, 964, 5143, 2397, 1030, 7261, 2459, 3784, 707, 4690, 5642,
                956, 9660, 1463, 7251, 3281, 3733, 3033, 1953, 942, 3316, 886, 1900, 1433, 3602,
                4688, 4131, 8638, 6928, 4074, 529, 4125, 3192, 5338, 5734, 5853, 7443, 6267, 6333,
                1465, 6982, 4006, 8018, 5632, 2927, 9912, 1866, 3928, 1185, 7154, 4538, 8721, 4978,
                5490, 6072, 6706, 7477, 5970, 5766, 5176, 6489, 7723, 8377, 281, 6067, 2087, 4955,
                2753, 4952, 9287, 2077, 8988, 2450, 2735, 7499, 2495, 2215, 2640, 1306, 4160, 3858,
                5832, 5165, 2811, 4543, 7751, 5075, 1266, 7019, 2524, 9011, 5788, 7368, 1761, 2553,
                5175, 1134, 3061, 7858, 8759, 573, 768, 3141, 5833, 5998, 8319, 5822, 8252, 6137,
                5605, 1973, 3026, 6152, 535, 4439, 3444, 1023, 4047, 4988, 5359, 9230, 6603, 4004,
                5894, 811, 3798, 4761, 9314, 112, 3201, 1592, 2220, 3650, 6044, 8293, 4367, 2308,
                2661, 3737, 1236, 5103, 9395, 8368, 8344, 8839, 9835, 8879, 7080, 7199, 9517, 8385,
                7783, 2997, 8396, 5827, 3203, 7096, 1216, 4538, 3363, 3751, 2332, 2189, 3412, 348,
                2681, 7958, 5946, 3014, 808, 5904, 1352, 9990, 3889, 3464, 1427, 7230, 3217, 9857,
                5611, 2704, 9423, 295, 3565, 5179, 7871, 9046, 594, 859, 6010, 8192, 9162, 5727,
                2221, 7999, 1120, 8376, 5224, 9293, 5105, 9915, 5207, 9387, 1468, 7880, 5538, 6809,
                1172, 4294, 1032, 5292, 313, 2953, 5366, 3700, 5130, 4301, 4136, 5018, 7989, 6816,
                197, 4826, 2661, 4765, 797, 1898, 7069, 7056, 3562, 4560, 5841, 9266, 8097, 9438,
                4609, 9971, 4193, 2825, 5287, 2340, 5763, 1550, 6505, 5847, 8558, 9290, 3151, 6486,
                7361, 2459, 7883, 3980, 619, 4057, 1295, 1156, 632, 8510, 8309, 7728, 9339, 7935,
                5362, 8527, 2793, 9226, 8146, 6516, 217, 6325, 9055, 9212, 7382, 2710, 9722, 9645,
                6114, 846, 6035, 5783, 7173, 3892, 8957, 4975, 1446, 7240, 5851, 3199, 2644, 2207,
                7246, 739, 5965, 9296, 5525, 2842, 9319, 8035, 7837, 138, 9437, 3834, 9986, 974,
                7277, 2680,
            ],
            9411,
            99,
        )
    }

    #[test]
    fn discussion_case3() {
        // test 52
        test(&[1, 8, 6, 10], 8, 3)
    }

    #[test]
    fn failing_case1() {
        test(
            &[
                5772, 9909, 6522, 8397, 9259, 2808, 5341, 8686, 1155, 816, 249, 9429, 4881, 1629,
                7383, 1428, 11, 780, 4607, 8991, 4998, 9690, 4169, 7515, 6279, 1921, 3662, 5016,
                2059, 8352, 8217, 395, 5998, 7313, 1547, 7061, 2545, 4503, 1866, 6115, 4135, 3458,
                5383, 2309, 9146, 3654, 122, 3770, 7906, 5880, 2085, 6692, 5620, 7004, 7209, 1834,
                4102, 869, 8641, 4839, 8441, 5222, 3262, 3412, 3759, 3966, 6163, 5686, 4202, 25,
                8064, 8304, 2303, 7008, 7926, 1482, 8462, 4523, 1638, 3593, 1777, 6982, 6637, 2330,
                1880, 7203, 8488, 3546, 2643, 3530, 4466, 5992, 5350, 5691, 4126, 9288, 2447, 509,
                3627, 4215, 7900, 9765, 8782, 262, 5603, 275, 2860, 3292, 4253, 3770, 1198, 6982,
                6047, 6068, 3106, 1730, 75, 6428, 5556, 9391, 5404, 6724, 5621, 9643, 4217, 6596,
                4520, 5788, 1230, 7165, 3655, 7734, 5672, 4634, 480, 1740, 9744, 8702, 882, 2803,
                3692, 8774, 7198, 4815, 6936, 6529, 75, 1115, 6503, 2503, 9618, 3403, 7769, 6452,
                8090, 1620, 6720, 2704, 8075, 3522, 5060, 9135, 593, 4896, 4801, 2275, 4114, 8427,
                4979, 7799, 2186, 7151, 5464, 8543, 5263, 3456, 4553, 651, 5089, 8232, 9417, 4828,
                8147, 4900, 4329, 2617, 4748, 4312, 5473, 2442, 4242, 6345, 7241, 8109, 2761, 6285,
                649, 1520, 9550, 3371, 5194, 838, 8568, 5005, 658, 6808, 1783, 5308, 2118, 171,
                5643, 3956, 5806, 8506, 7120, 3946, 8525, 1371, 536, 5488, 312, 7268, 428, 2761,
                4605, 3432, 7027, 4740, 2703, 720, 638, 8147, 6396, 8871, 1827, 6226, 4717, 7146,
                818, 3754, 5467, 6870, 9632, 9434, 7978, 9830, 3329, 9495, 8379, 1458, 5515, 6630,
                2939, 3858, 8473, 7952, 1184, 6866, 6476, 3575, 4189, 26, 4619, 534, 4261, 1398,
                2946, 4140, 7354, 7123, 5005, 1645, 4871, 884, 7819, 2877, 4169, 8992, 3421, 2066,
                691, 6542, 9025, 163, 9293, 8246, 4868, 45, 6254, 5569, 1587, 4208, 2654, 9795,
                3276, 1190, 2865, 9462, 6180, 8697, 9286, 382, 3610, 6655, 293, 70, 8647, 6811,
                2880, 875, 6485, 6790, 3128, 2608, 3639, 1501, 7405, 8848, 8920, 5480, 4099, 3143,
                8307, 9763, 4191, 6367, 4054, 4792, 4224, 2411, 4358, 5926, 9477, 4515, 8197, 3587,
                3102, 8800, 360, 1727, 3582, 4517, 2765, 5277, 3599, 2668, 538, 9970, 3591, 6356,
                4289, 4220, 3478, 4282, 6153, 685, 541, 2521, 8144, 7153, 4938, 6006, 6647, 5834,
                3244, 4696, 4592, 4330, 7919, 2502, 9505, 5843, 2319, 6386, 1003, 1184, 4264, 1235,
                8088, 3411, 7436, 5039, 660, 4406, 5524, 71, 8117, 7069, 7068, 6941, 6007, 9971,
                7962, 3172, 7087, 6416, 4739, 1575, 1326, 2640, 5525, 5986, 9314, 7036, 6259, 2017,
                6168, 851, 7107, 9963, 3295, 1847, 3756, 7827, 6286, 2833, 2181, 3607, 1571, 5684,
                5295, 8287, 7201, 2732, 6200, 7934, 9229, 3019, 613, 8252, 3252, 4096, 2152, 1958,
                4485, 9126, 215, 81, 6094, 4678, 3517, 892, 5109, 2426, 2088, 1104, 2563, 9658,
                6850, 4398, 2142, 1196, 3168, 2633, 9864, 6829, 3549, 6433, 8865, 8032, 2837, 9884,
                1056, 8168, 3978, 3341, 1193, 2485, 4007, 3102, 9997, 2414, 8984, 4253, 1070, 9406,
                6098, 1293, 5825, 8656, 4568, 2938, 9289, 7696, 7104, 9123, 9433, 9176, 3617, 2067,
                9076, 9651, 1926, 7136, 7023, 6025, 3669, 7271, 9212, 6419, 5449, 9294, 3005, 858,
                799, 6018, 7592, 2647, 7646, 9387, 6115, 5769, 2560, 7494, 3293, 8952, 7820, 8782,
                4624, 9795, 3409, 2081, 9979, 3611, 4632, 1734, 1443, 3719, 6954, 8390, 3510, 4927,
                8065, 1011, 6155, 3343, 876, 5063, 4906, 3454, 7024, 205, 7483, 5335, 6877, 3998,
                1725, 2763, 8281, 836, 6262, 2670, 283, 8429, 8126, 7951, 6043, 8999, 6989, 472,
                9731, 7143, 6377, 3892, 8486, 134, 9172, 708, 3273, 5171, 586, 2210, 7188, 2925,
                7407, 2399, 2353, 4123, 8258, 6259, 1522, 8396, 2023, 1163, 6284, 7929, 6007, 3450,
                617, 8681, 6707, 3614, 7882, 3239, 2767, 3879, 3230, 8686, 5548, 4894, 7823, 9412,
                8289, 3854, 3491, 4614, 2020, 9338, 168, 601, 5168, 1458, 8656, 2926, 7474, 8860,
                1319, 6714, 2299, 8914, 711, 2297, 5238, 5877, 7406, 3122, 6559, 7596, 1408, 6461,
                5995, 161, 4672, 3467, 9576, 5834, 6136, 123, 1555, 7297, 6641, 5025, 2840, 4902,
                3593, 5407, 5447, 3471, 671, 835, 305, 2982, 9849, 7577, 5313, 602, 4358, 9727,
                8609, 4449, 1079, 4095, 195, 2131, 6772, 5693, 4424, 8167, 640, 6321, 1816, 5002,
                6869, 4067, 3759, 8486, 9560, 7144, 9291, 4326, 171, 96, 2483, 7782, 2444, 5736,
                1272, 9797, 4055, 9125, 9016, 2529, 2175, 6571, 2275, 5410, 3184, 2122, 2243, 9962,
                1909, 2085, 548, 9764, 4559, 4474, 5775, 122, 2382, 143, 1045, 7475, 7092, 6515,
                5070, 2191, 6418, 6981, 5899, 7339, 5732, 4791, 7786, 3042, 4407, 131, 5104, 3768,
                871, 8184, 978, 124, 1297, 9731, 7590, 42, 4022, 2171, 6424, 6365, 3646, 9725,
                4536, 3004, 3575, 2647, 1485, 5413, 5684, 1412, 1999, 9114, 3781, 3354, 5384, 9178,
                8789, 7340, 1357, 7068, 9366, 5839, 2705, 2968, 1666, 5805, 3027, 8082, 1299, 7473,
                7068, 3583, 1039, 1110, 4124, 5379, 6424, 6036, 9529, 5348, 7051, 8465, 9809, 1159,
                3117, 6745, 5696, 8631, 8147, 5679, 1956, 7331, 5396, 143, 3691, 4983, 6732, 2293,
                3138, 4557, 8340, 758, 2660, 9504, 5080, 934, 1823, 4354, 9657, 1830, 2945, 9146,
                7409, 9337, 4061, 7677, 7061, 895, 2309, 8075, 5896, 8242, 4781, 6151, 1459, 9273,
                7162, 2128, 8338, 3821, 7013, 7976, 1027, 9679, 5927, 8718, 8531, 3033, 1016, 3343,
                3106, 305, 5687, 3894, 3913, 8633, 8626, 6730, 9148, 6800, 2707, 3846, 13, 3599,
                8363, 8728, 930, 2546, 8991, 1479, 405, 2332, 8923, 4366, 3762, 5912, 5449, 2258,
                1537, 4192, 6761, 5827, 9730, 696, 8987, 1019, 7509, 620, 5153, 5102, 4919, 6385,
                5027, 6307, 7905, 4828, 1965, 9586, 186, 1733, 6947, 1206, 3418, 2017, 155, 4025,
                7688, 1162, 3485, 5585, 3520, 4851, 4682, 7621, 7621, 9148, 9391, 8347, 3448, 7584,
                6169, 1369, 506, 1209, 4930, 7363, 3357, 4838, 6789, 3031, 9941, 6467, 6145, 7587,
                3627, 4042, 8089, 231, 4795, 4397, 7769, 8086, 5768, 1794, 9719, 1965, 3508, 7316,
                6358, 3523, 6900, 1011, 2884, 6333, 6965, 6121, 8612, 2322, 1114, 8385, 2618, 737,
                9539, 3476, 8238, 8906, 7624, 5080, 4931, 7791, 2208, 345, 7393, 7106, 9482, 5654,
                7139, 5953, 3570, 4428, 3332, 7556, 9457, 7763, 4447, 6807, 4662, 4538, 7272, 1079,
                1822, 5329, 7336, 4707, 8502, 3718, 8341, 5247, 4068, 2541, 2573, 4167, 4066, 6747,
                495, 7034,
            ],
            6405,
            17,
        )
    }

    #[test]
    fn failing_case1_v2() {
        test(
            &[
                5772, 9909, 6522, 8397, 9259, 2808, 5341, 8686, 1155, 816, 249, 9429, 4881, 1629,
                7383, 1428, 11, 780, 4607, 8991, 4998, 9690, 4169, 7515, 6279, 1921, 3662, 5016,
                2059, 8352, 8217, 395, 5998, 7313, 1547, 7061, 2545, 4503, 1866, 6115, 4135, 3458,
                5383, 2309, 9146, 3654, 122, 3770, 7906, 5880, 2085, 6692, 5620, 7004, 7209, 1834,
                4102, 869, 8641, 4839, 8441, 5222, 3262, 3412, 3759, 3966, 6163, 5686, 4202, 25,
                8064, 8304, 2303, 7008, 7926, 1482, 8462, 4523, 1638, 3593, 1777, 6982, 6637, 2330,
                1880, 7203, 8488, 3546, 2643, 3530, 4466, 5992, 5350, 5691, 4126, 9288, 2447, 509,
                3627, 4215, 7900, 9765, 8782, 262, 5603, 275, 2860, 3292, 4253, 3770, 1198, 6982,
                6047, 6068, 3106, 1730, 75, 6428, 5556, 9391, 5404, 6724, 5621, 9643, 4217, 6596,
                4520, 5788, 1230, 7165, 3655, 7734, 5672, 4634, 480, 1740, 9744, 8702, 882, 2803,
                3692, 8774, 7198, 4815, 6936, 6529, 75, 1115, 6503, 2503, 9618, 3403, 7769, 6452,
                8090, 1620, 6720, 2704, 8075, 3522, 5060, 9135, 593, 4896, 4801, 2275, 4114, 8427,
                4979, 7799, 2186, 7151, 5464, 8543, 5263, 3456, 4553, 651, 5089, 8232, 9417, 4828,
                8147, 4900, 4329, 2617, 4748, 4312, 5473, 2442, 4242, 6345, 7241, 8109, 2761, 6285,
                649, 1520, 9550, 3371, 5194, 838, 8568, 5005, 658, 6808, 1783, 5308, 2118, 171,
                5643, 3956, 5806, 8506, 7120, 3946, 8525, 1371, 536, 5488, 312, 7268, 428, 2761,
                4605, 3432, 7027, 4740, 2703, 720, 638, 8147, 6396, 8871, 1827, 6226, 4717, 7146,
                818, 3754, 5467, 6870, 9632, 9434, 7978, 9830, 3329, 9495, 8379, 1458, 5515, 6630,
                2939, 3858, 8473, 7952, 1184, 6866, 6476, 3575, 4189, 26, 4619, 534, 4261, 1398,
                2946, 4140, 7354, 7123, 5005, 1645, 4871, 884, 7819, 2877, 4169, 8992, 3421, 2066,
                691, 6542, 9025, 163, 9293, 8246, 4868,
            ],
            6405,
            15,
        )
    }

    #[test]
    fn failing_case1_v2_1() {
        test(
            &[
                5772, 9909, 6522, 8397, 9259, 2808, 5341, 8686, 1155, 816, 249, 9429, 4881, 1629,
                7383, 1428, 11, 780, 4607, 8991, 4998, 9690, 4169, 7515, 6279, 1921, 3662, 5016,
                2059, 8352, 8217, 395, 5998, 7313, 1547, 7061, 2545, 4503, 1866, 6115, 4135, 3458,
                5383, 2309, 9146, 3654, 122, 3770, 7906, 5880, 2085, 6692, 5620, 7004, 7209, 1834,
                4102, 869, 8641, 4839, 8441, 5222, 3262, 3412, 3759, 3966, 6163, 5686, 4202, 25,
                8064, 8304, 2303, 7008, 7926, 1482, 8462, 4523, 1638, 3593, 1777, 6982, 6637, 2330,
                1880, 7203, 8488, 3546, 2643, 3530, 4466, 5992, 5350, 5691, 4126, 9288, 2447, 509,
                3627, 4215, 7900, 9765, 8782, 262, 5603, 275, 2860, 3292, 4253, 3770, 1198, 6982,
                6047, 6068, 3106, 1730, 75, 6428, 5556, 9391, 5404, 6724, 5621, 9643, 4217, 6596,
                4520, 5788, 1230, 7165, 3655, 7734, 5672, 4634, 480, 1740, 9744, 8702, 882, 2803,
                3692,
            ],
            6405,
            12,
        )
    }

    #[test]
    fn failing_case1_v2_2() {
        test(
            &[
                8774, 7198, 4815, 6936, 6529, 75, 1115, 6503, 2503, 9618, 3403, 7769, 6452, 8090,
                1620, 6720, 2704, 8075, 3522, 5060, 9135, 593, 4896, 4801, 2275, 4114, 8427, 4979,
                7799, 2186, 7151, 5464, 8543, 5263, 3456, 4553, 651, 5089, 8232, 9417, 4828, 8147,
                4900, 4329, 2617, 4748, 4312, 5473, 2442, 4242, 6345, 7241, 8109, 2761, 6285, 649,
                1520, 9550, 3371, 5194, 838, 8568, 5005, 658, 6808, 1783, 5308, 2118, 171, 5643,
                3956, 5806, 8506, 7120, 3946, 8525, 1371, 536, 5488, 312, 7268, 428, 2761, 4605,
                3432, 7027, 4740, 2703, 720, 638, 8147, 6396, 8871, 1827, 6226, 4717, 7146, 818,
                3754, 5467, 6870, 9632, 9434, 7978, 9830, 3329, 9495, 8379, 1458, 5515, 6630, 2939,
                3858, 8473, 7952, 1184, 6866, 6476, 3575, 4189, 26, 4619, 534, 4261, 1398, 2946,
                4140, 7354, 7123, 5005, 1645, 4871, 884, 7819, 2877, 4169, 8992, 3421, 2066, 691,
                6542, 9025, 163, 9293, 8246, 4868,
            ],
            6405,
            15,
        )
    }

    #[test]
    fn failing_case1_v2_3() {
        test(
            &[
                8641, 4839, 8441, 5222, 3262, 3412, 3759, 3966, 6163, 5686, 4202, 25, 8064, 8304,
                2303, 7008, 7926, 1482, 8462, 4523, 1638, 3593, 1777, 6982, 6637, 2330, 1880, 7203,
                8488, 3546, 2643, 3530, 4466, 5992, 5350, 5691, 4126, 9288, 2447, 509, 3627, 4215,
                7900, 9765, 8782, 262, 5603, 275, 2860, 3292, 4253, 3770, 1198, 6982, 6047, 6068,
                3106, 1730, 75, 6428, 5556, 9391, 5404, 6724, 5621, 9643, 4217, 6596, 4520, 5788,
                1230, 7165, 3655, 7734, 5672, 4634, 480, 1740, 9744, 8702, 882, 2803, 3692, 8774,
                7198, 4815, 6936, 6529, 75, 1115, 6503, 2503, 9618, 3403, 7769, 6452, 8090, 1620,
                6720, 2704, 8075, 3522, 5060, 9135, 593, 4896, 4801, 2275, 4114, 8427, 4979, 7799,
                2186, 7151, 5464, 8543, 5263, 3456, 4553, 651, 5089, 8232, 9417, 4828, 8147, 4900,
                4329, 2617, 4748, 4312, 5473, 2442, 4242, 6345, 7241, 8109, 2761, 6285, 649, 1520,
                9550, 3371, 5194, 838, 8568, 5005, 658, 6808, 1783, 5308, 2118, 171, 5643, 3956,
                5806, 8506, 7120, 3946, 8525, 1371, 536, 5488, 312, 7268, 428, 2761, 4605, 3432,
                7027, 4740, 2703, 720, 638, 8147, 6396, 8871, 1827, 6226, 4717,
            ],
            6405,
            15,
        )
    }

    #[test]
    fn tle_case1() {
        test(&[1; 100000], 10, 100000)
    }

    #[test]
    fn myex1() {
        test(&[1, 2, 1, 2], 0, 1)
    }

    #[test]
    fn myex123_1() {
        test(&[1, 2, 3, 1, 2, 3, 1, 2, 3], 1, 2)
    }

    #[test]
    fn myex123_2() {
        test(&[1, 2, 3, 1, 2, 3, 1, 2, 3], 2, 9)
    }
}
