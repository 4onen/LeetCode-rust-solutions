// https://leetcode.com/problems/generate-parentheses/

pub struct Solution;

impl Solution {
    pub fn generate_parenthesis(n: i32) -> Vec<String> {
        assert!(n > 0);
        let n = n as u8;
        const LUT: [&[&str]; 6] = [
            &["()"],
            &["(())", "()()"],
            &["((()))", "(()())", "(())()", "()(())", "()()()"],
            &[
                "(((())))", "((()()))", "((())())", "((()))()", "(()(()))", "(()()())", "(()())()",
                "(())(())", "(())()()", "()((()))", "()(()())", "()(())()", "()()(())", "()()()()",
            ],
            &[
                "((((()))))",
                "(((()())))",
                "(((())()))",
                "(((()))())",
                "(((())))()",
                "((()(())))",
                "((()()()))",
                "((()())())",
                "((()()))()",
                "((())(()))",
                "((())()())",
                "((())())()",
                "((()))(())",
                "((()))()()",
                "(()((())))",
                "(()(()()))",
                "(()(())())",
                "(()(()))()",
                "(()()(()))",
                "(()()()())",
                "(()()())()",
                "(()())(())",
                "(()())()()",
                "(())((()))",
                "(())(()())",
                "(())(())()",
                "(())()(())",
                "(())()()()",
                "()(((())))",
                "()((()()))",
                "()((())())",
                "()((()))()",
                "()(()(()))",
                "()(()()())",
                "()(()())()",
                "()(())(())",
                "()(())()()",
                "()()((()))",
                "()()(()())",
                "()()(())()",
                "()()()(())",
                "()()()()()",
            ],
            &[
                "(((((())))))",
                "((((()()))))",
                "((((())())))",
                "((((()))()))",
                "((((())))())",
                "((((()))))()",
                "(((()(()))))",
                "(((()()())))",
                "(((()())()))",
                "(((()()))())",
                "(((()())))()",
                "(((())(())))",
                "(((())()()))",
                "(((())())())",
                "(((())()))()",
                "(((()))(()))",
                "(((()))()())",
                "(((()))())()",
                "(((())))(())",
                "(((())))()()",
                "((()((()))))",
                "((()(()())))",
                "((()(())()))",
                "((()(()))())",
                "((()(())))()",
                "((()()(())))",
                "((()()()()))",
                "((()()())())",
                "((()()()))()",
                "((()())(()))",
                "((()())()())",
                "((()())())()",
                "((()()))(())",
                "((()()))()()",
                "((())((())))",
                "((())(()()))",
                "((())(())())",
                "((())(()))()",
                "((())()(()))",
                "((())()()())",
                "((())()())()",
                "((())())(())",
                "((())())()()",
                "((()))((()))",
                "((()))(()())",
                "((()))(())()",
                "((()))()(())",
                "((()))()()()",
                "(()(((()))))",
                "(()((()())))",
                "(()((())()))",
                "(()((()))())",
                "(()((())))()",
                "(()(()(())))",
                "(()(()()()))",
                "(()(()())())",
                "(()(()()))()",
                "(()(())(()))",
                "(()(())()())",
                "(()(())())()",
                "(()(()))(())",
                "(()(()))()()",
                "(()()((())))",
                "(()()(()()))",
                "(()()(())())",
                "(()()(()))()",
                "(()()()(()))",
                "(()()()()())",
                "(()()()())()",
                "(()()())(())",
                "(()()())()()",
                "(()())((()))",
                "(()())(()())",
                "(()())(())()",
                "(()())()(())",
                "(()())()()()",
                "(())(((())))",
                "(())((()()))",
                "(())((())())",
                "(())((()))()",
                "(())(()(()))",
                "(())(()()())",
                "(())(()())()",
                "(())(())(())",
                "(())(())()()",
                "(())()((()))",
                "(())()(()())",
                "(())()(())()",
                "(())()()(())",
                "(())()()()()",
                "()((((()))))",
                "()(((()())))",
                "()(((())()))",
                "()(((()))())",
                "()(((())))()",
                "()((()(())))",
                "()((()()()))",
                "()((()())())",
                "()((()()))()",
                "()((())(()))",
                "()((())()())",
                "()((())())()",
                "()((()))(())",
                "()((()))()()",
                "()(()((())))",
                "()(()(()()))",
                "()(()(())())",
                "()(()(()))()",
                "()(()()(()))",
                "()(()()()())",
                "()(()()())()",
                "()(()())(())",
                "()(()())()()",
                "()(())((()))",
                "()(())(()())",
                "()(())(())()",
                "()(())()(())",
                "()(())()()()",
                "()()(((())))",
                "()()((()()))",
                "()()((())())",
                "()()((()))()",
                "()()(()(()))",
                "()()(()()())",
                "()()(()())()",
                "()()(())(())",
                "()()(())()()",
                "()()()((()))",
                "()()()(()())",
                "()()()(())()",
                "()()()()(())",
                "()()()()()()",
            ],
        ];
        match n {
            1..=6 => LUT[n as usize - 1]
                .into_iter()
                .map(|s| s.to_string())
                .collect::<Vec<String>>(),
            _ => {
                let mut result = vec![];
                fn generate_recurse(result: &mut Vec<String>, s: &mut String, left: u8, right: u8) {
                    if left == 0 && right == 0 {
                        result.push(s.clone());
                    } else {
                        if left > 0 {
                            s.push('(');
                            generate_recurse(result, s, left - 1, right);
                            s.pop();
                        }
                        if right > left {
                            s.push(')');
                            generate_recurse(result, s, left, right - 1);
                            s.pop();
                        }
                    }
                }
                generate_recurse(
                    &mut result,
                    &mut String::with_capacity(n as usize * 2),
                    n,
                    n,
                );
                result
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn ex1() {
        let n = 3;
        let expected = vec!["((()))", "(()())", "(())()", "()(())", "()()()"];
        let result = Solution::generate_parenthesis(n);
        assert_eq!(result, expected);
    }

    #[test]
    fn ex2() {
        let n = 1;
        let expected = vec!["()"];
        let result = Solution::generate_parenthesis(n);
        assert_eq!(result, expected);
    }

    #[test]
    fn myex2() {
        let n = 2;
        let expected = vec!["(())", "()()"];
        let result = Solution::generate_parenthesis(n);
        assert_eq!(result, expected);
    }

    #[test]
    fn myex4() {
        let n = 4;
        let expected = vec![
            "(((())))", "((()()))", "((())())", "((()))()", "(()(()))", "(()()())", "(()())()",
            "(())(())", "(())()()", "()((()))", "()(()())", "()(())()", "()()(())", "()()()()",
        ];
        let result = Solution::generate_parenthesis(n);
        assert_eq!(result.len(), 14);
        assert_eq!(result, expected);
    }

    #[test]
    fn myex5() {
        let n = 5;
        let expected = vec![
            "((((()))))",
            "(((()())))",
            "(((())()))",
            "(((()))())",
            "(((())))()",
            "((()(())))",
            "((()()()))",
            "((()())())",
            "((()()))()",
            "((())(()))",
            "((())()())",
            "((())())()",
            "((()))(())",
            "((()))()()",
            "(()((())))",
            "(()(()()))",
            "(()(())())",
            "(()(()))()",
            "(()()(()))",
            "(()()()())",
            "(()()())()",
            "(()())(())",
            "(()())()()",
            "(())((()))",
            "(())(()())",
            "(())(())()",
            "(())()(())",
            "(())()()()",
            "()(((())))",
            "()((()()))",
            "()((())())",
            "()((()))()",
            "()(()(()))",
            "()(()()())",
            "()(()())()",
            "()(())(())",
            "()(())()()",
            "()()((()))",
            "()()(()())",
            "()()(())()",
            "()()()(())",
            "()()()()()",
        ];
        let result = Solution::generate_parenthesis(n);
        assert_eq!(result.len(), 42);
        assert_eq!(result, expected);
    }

    #[test]
    fn myex6() {
        let n = 6;
        let result = Solution::generate_parenthesis(n);
        assert_eq!(result.len(), 132);
    }

    #[test]
    fn myex7() {
        let n = 7;
        let result = Solution::generate_parenthesis(n);
        assert_eq!(result.len(), 429);
    }

    #[test]
    fn myex8() {
        let n = 8;
        let result = Solution::generate_parenthesis(n);
        assert_eq!(result.len(), 1430);
    }
}
